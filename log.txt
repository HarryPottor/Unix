
======================================
				7
=====================================
程序的执行：
编译器 调用 连接器 设置启动例程为程序的起始地址，
启动例程 从内核中取得 命令行参数和环境变量值，为main函数的调用做好准备。

进程的正常终止：
1 从main返回
2 调用exit
3 调用_exit / _Exit;
4 最后一个线程 从 它的启动例程 返回
5 最后一个线程 调用 pthread_exit()

进程非正常终止:
1 调用abort
2 接收到信号
3 最后一个线程 对 取消请求做出相应

stdlib.h
void exit(int);清理，再进入内核
	(对于所有打开流调用flose 函数，将使输出缓冲中的所有数据都被冲洗)
void _Exit(int);立即进入内核
unistd.h
void _exit(int);立即进入内核

终止状态未定义：
1 上边的函数未带参数 例如 exit()
2 main调用无返回值得return。即 return;
3 main没有声明返回类型为整型
* 如果main返回类型为整型，且隐式返回，则终止状态为0
** 查看终止状态: echo $?


atexit(void (*func)(void))函数：
登记至少支持32个函数，这些函数由exit自动调用
这些函数 为 终止处理程序
exit 函数 首先调用各个 终止处理程序，然后在关闭所有打开流
终止处理程序 
	每登记一次，就会被调用一次，但调用时机是程序结束以后，调用顺序是登记的倒序

内核 使 程序执行 的唯一方法是调用一个 exec函数。
进程自愿终止的唯一方法是 显式或隐式的调用 _exit, _Exit
	非自愿的方法 由信号使其终止。


程序除了有 参数表，还有一个 环境表。
环境表与参数表类似，指向字符串的指针数组，最后一项为NULL
extern char ** environ

程序分段：
----------------------------------
命令行参数和环境变量
栈
↓

↑
堆
未初始化的数据
初始化的数据
正文
----------------------------------
* 其中存放在磁盘程序文件中的段只有 正文段和初始化数据段
* size 查看程序的各段长度 例：size /bin/sh
cc -static hello.c 不使用动态库的编译