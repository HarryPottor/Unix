
======================================
				7
=====================================
程序的执行：
编译器 调用 连接器 设置启动例程为程序的起始地址，
启动例程 从内核中取得 命令行参数和环境变量值，为main函数的调用做好准备。

进程的正常终止：
1 从main返回
2 调用exit
3 调用_exit / _Exit;
4 最后一个线程 从 它的启动例程 返回
5 最后一个线程 调用 pthread_exit()

进程非正常终止:
1 调用abort
2 接收到信号
3 最后一个线程 对 取消请求做出相应

stdlib.h
void exit(int);清理，再进入内核
	(对于所有打开流调用flose 函数，将使输出缓冲中的所有数据都被冲洗)
void _Exit(int);立即进入内核
unistd.h
void _exit(int);立即进入内核

终止状态未定义：
1 上边的函数未带参数 例如 exit()
2 main调用无返回值得return。即 return;
3 main没有声明返回类型为整型
* 如果main返回类型为整型，且隐式返回，则终止状态为0
** 查看终止状态: echo $?


atexit(void (*func)(void))函数：
登记至少支持32个函数，这些函数由exit自动调用
这些函数 为 终止处理程序
exit 函数 首先调用各个 终止处理程序，然后在关闭所有打开流
终止处理程序 
	每登记一次，就会被调用一次，但调用时机是程序结束以后，调用顺序是登记的倒序

内核 使 程序执行 的唯一方法是调用一个 exec函数。
进程自愿终止的唯一方法是 显式或隐式的调用 _exit, _Exit
	非自愿的方法 由信号使其终止。


程序除了有 参数表，还有一个 环境表。
环境表与参数表类似，指向字符串的指针数组，最后一项为NULL
extern char ** environ

程序分段：
----------------------------------
命令行参数和环境变量
栈
↓

↑
堆
未初始化的数据
初始化的数据
正文
----------------------------------
* 其中存放在磁盘程序文件中的段只有 正文段和初始化数据段
* size 查看程序的各段长度 例：size /bin/sh
cc -static hello.c 不使用动态库的编译

stdlib.h
void * malloc(size_t size) 不进行初始化
void * calloc(size_t objsz, size_t size) 初始化为0
void * realloc(void * ptr, size_t newsize) 新增区域的初始化值不确定


==============================================8=========================================
进程ID 0 调度进程
进程ID 1 init进程
进程ID 2 页守护进程

unistd.h
pid_t getpid();
pid_t getppid();
pid_t getuid(); 实际用户ID
pid_t geteuid(); 有效用户ID
pid_t getgid();	实际组ID
pid_t getegid(); 有效组ID

pid_t fork(void);
对父进程 返回 子进程ID：因为一个进程的子进程可以有很多，并且没有一个函数
	使一个进程可以获得其所有子进程的进程ID
对子进程 返回 0 ：一个进程只会有一个父进程，所以子进程总可以调用getppid
以获得其父进程的进程ID

*** fork后，子进程是父进程的副本，子进程获得父进程数据 数据空间，堆，栈 的副本
	这是子进程所拥有的副本，父子并不共享。只共享正文段。
**** 一般fork后经常跟随exec，所以子进程不一定需要父进程数据的副本，所以才用写时复制
	技术，这些区域由父子共享，内核设为只读权限；当试图修改时内核为修改区域的内存制作
	一个副本，通常是虚拟存储系统中的一页。

strlen 与 sizeof
对一个给定的字符串 char buf="abcdef";
strlen(buf) 进行了一次函数调用
sizeof(buf) 因为缓冲区已用已知字符串进行初始化，其长度是固定的，所以sizeof是在编译时
	计算缓冲区长度。

*** 当 标准输出 连到 终端设备，则它是行缓冲的，遇到\n会清空缓冲区；
	如果重定向到文件 则是全缓冲。进行fork的时候，缓冲区也会被拷贝过来...

vfork()
** 并不将父进程的地址空间完全复制到子进程中，子进程在调用exec或exit之前，它在父进程的空间中运行，
	如果子进程修改了数据，或者没有调用exit 则结果未知。
	保证子进程先运行，调用exec或exit之后父进程才激活。
**	子进程修改的数据，其实是父进程的。
*** exit与_exit
	_exit 不执行标准I/O缓冲区的冲洗操作
	exit 则可能会执行两方面内容：冲洗I/O流，关闭标准I/O流,清空相关缓冲区。
*** 所以 如果exit执行了两方面内容，那当时存在缓冲区的数据是不存在的。

